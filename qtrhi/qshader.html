<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qshader.cpp -->
  <title>QShader Class | RHI 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td >Qt 5.12</td><td ><a href="qtrhi-index.html">RHI</a></td><td ><a href="qtrhi-module.html">C++ Classes</a></td><td >QShader</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.12.0 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QShader Class</h1>
<!-- $$$QShader-brief -->
<p>Contains multiple versions of a shader translated to multiple shading languages, together with reflection metadata. <a href="#details">More...</a></p>
<!-- @@@QShader -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QShader&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += rhi</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.14</td></tr></table></div><ul>
<li><a href="qshader-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#Source-enum">Source</a></b> { SpirvShader, GlslShader, HlslShader, DxbcShader, ..., MetalLibShader }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#Stage-enum">Stage</a></b> { VertexStage, TessellationControlStage, TessellationEvaluationStage, GeometryStage, FragmentStage, ComputeStage }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#Variant-enum">Variant</a></b> { StandardShader, BatchableVertexShader }</td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#QShader">QShader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#dtor.QShader">~QShader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderKey&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#availableShaders">availableShaders</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#description">description</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#isValid">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#removeShader">removeShader</a></b>(const QShaderKey &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#serialized">serialized</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setDescription">setDescription</a></b>(const int &amp;<i>desc</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setShader">setShader</a></b>(const QShaderKey &amp;<i>key</i>, const QShaderCode &amp;<i>shader</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#setStage">setStage</a></b>(QShader::Stage <i>stage</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShaderCode </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#shader">shader</a></b>(const QShaderKey &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QShader::Stage </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#stage">stage</a></b>() const</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QShader </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#fromSerialized">fromSerialized</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
</table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#qHash">qHash</a></b>(const QShader &amp;<i>s</i>, uint <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#operator-not-eq">operator!=</a></b>(const QShader &amp;<i>lhs</i>, const QShader &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qshader.html#operator-eq-eq">operator==</a></b>(const QShader &amp;<i>lhs</i>, const QShader &amp;<i>rhs</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QShader-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Contains multiple versions of a shader translated to multiple shading languages, together with reflection metadata.</p>
<p><a href="qshader.html">QShader</a> is the entry point to shader code in the graphics API agnostic Qt world. Instead of using GLSL shader sources, as was the custom with Qt 5.x, new graphics systems with backends for multiple graphics APIs, such as, Vulkan, Metal, Direct3D, and OpenGL, take <a href="qshader.html">QShader</a> as their input whenever a shader needs to be specified.</p>
<p>A <a href="qshader.html">QShader</a> instance is empty and thus invalid by default. To get a useful instance, the two typical methods are:</p>
<ul>
<li>Generate the contents offline, during build time or earlier, using the <code>qsb</code> command line tool. The result is a binary file that is shipped with the application, read via <a href="../qtcore/qiodevice.html#readAll">QIODevice::readAll</a>(), and then deserialized via <a href="qshader.html#fromSerialized">fromSerialized</a>(). For more information, see QShaderBaker.</li>
<li>Generate at run time via QShaderBaker. This is an expensive operation, but allows applications to use user-provided or dynamically generated shader source strings.</li>
</ul>
<p>When used together with the Qt Rendering Hardware Interface and its classes, like <a href="qrhigraphicspipeline.html">QRhiGraphicsPipeline</a>, no further action is needed from the application's side as these classes are prepared to consume a <a href="qshader.html">QShader</a> whenever a shader needs to be specified for a given stage of the graphics pipeline.</p>
<p>Alternatively, applications can access</p>
<ul>
<li>the source or byte code for any of the shading language versions that are included in the <a href="qshader.html">QShader</a>,</li>
<li>the name of the entry point for the shader,</li>
<li>the reflection metadata containing a description of the shader's inputs, outputs and resources like uniform blocks. This is essential when an application or framework needs to discover the inputs of a shader at runtime due to not having advance knowledge of the vertex attributes or the layout of the uniform buffers used by the shader.</li>
</ul>
<p><a href="qshader.html">QShader</a> makes no assumption about the shading language that was used as the source for generating the various versions and variants that are included in it.</p>
<p><a href="qshader.html">QShader</a> uses implicit sharing similarly to many core Qt types, and so can be returned or passed by value. Detach happens implicitly when calling a setter.</p>
<p>For reference, <a href="qrhi.html">QRhi</a> expects that a <a href="qshader.html">QShader</a> suitable for all its backends contains at least the following:</p>
<ul>
<li>SPIR-V 1.0 bytecode suitable for Vulkan 1.0 or newer</li>
<li>GLSL/ES 100 source code suitable for OpenGL ES 2.0 or newer</li>
<li>GLSL 120 source code suitable for OpenGL 2.1</li>
<li>HLSL Shader Model 5.0 source code or the corresponding DXBC bytecode suitable for Direct3D 11</li>
<li>Metal Shading Language 1.2 source code or the corresponding bytecode suitable for Metal</li>
</ul>
</div>
<p><b>See also </b>QShaderBaker.</p>
<!-- @@@QShader -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Source$$$SpirvShader$$$GlslShader$$$HlslShader$$$DxbcShader$$$MslShader$$$DxilShader$$$MetalLibShader -->
<h3 class="fn" id="Source-enum"><a name="Source-enum"></a>enum QShader::<span class="name">Source</span></h3>
<p>Describes what kind of shader code an entry contains.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QShader::SpirvShader</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">SPIR-V</td></tr>
<tr><td class="topAlign"><code>QShader::GlslShader</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">GLSL</td></tr>
<tr><td class="topAlign"><code>QShader::HlslShader</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">HLSL</td></tr>
<tr><td class="topAlign"><code>QShader::DxbcShader</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">Direct3D bytecode (HLSL compiled by <code>fxc</code>)</td></tr>
<tr><td class="topAlign"><code>QShader::MslShader</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">Metal Shading Language</td></tr>
<tr><td class="topAlign"><code>QShader::DxilShader</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">Direct3D bytecode (HLSL compiled by <code>dxc</code>)</td></tr>
<tr><td class="topAlign"><code>QShader::MetalLibShader</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">Pre-compiled Metal bytecode</td></tr>
</table></div>
<!-- @@@Source -->
<!-- $$$Stage$$$VertexStage$$$TessellationControlStage$$$TessellationEvaluationStage$$$GeometryStage$$$FragmentStage$$$ComputeStage -->
<h3 class="fn" id="Stage-enum"><a name="Stage-enum"></a>enum QShader::<span class="name">Stage</span></h3>
<p>Describes the stage of the graphics pipeline the shader is suitable for.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QShader::VertexStage</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">Vertex shader</td></tr>
<tr><td class="topAlign"><code>QShader::TessellationControlStage</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">Tessellation control (hull) shader</td></tr>
<tr><td class="topAlign"><code>QShader::TessellationEvaluationStage</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Tessellation evaluation (domain) shader</td></tr>
<tr><td class="topAlign"><code>QShader::GeometryStage</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">Geometry shader</td></tr>
<tr><td class="topAlign"><code>QShader::FragmentStage</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">Fragment (pixel) shader</td></tr>
<tr><td class="topAlign"><code>QShader::ComputeStage</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">Compute shader</td></tr>
</table></div>
<!-- @@@Stage -->
<!-- $$$Variant$$$StandardShader$$$BatchableVertexShader -->
<h3 class="fn" id="Variant-enum"><a name="Variant-enum"></a>enum QShader::<span class="name">Variant</span></h3>
<p>Describes what kind of shader code an entry contains.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QShader::StandardShader</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">The normal, unmodified version of the shader code.</td></tr>
<tr><td class="topAlign"><code>QShader::BatchableVertexShader</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">Vertex shader rewritten to be suitable for Qt Quick scenegraph batching.</td></tr>
</table></div>
<!-- @@@Variant -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QShader[overload1]$$$QShader -->
<h3 class="fn" id="QShader"><a name="QShader"></a>QShader::<span class="name">QShader</span>()</h3>
<p>Constructs a new, empty (and thus invalid) <a href="qshader.html">QShader</a> instance.</p>
<!-- @@@QShader -->
<!-- $$$~QShader[overload1]$$$~QShader -->
<h3 class="fn" id="dtor.QShader"><a name="dtor.QShader"></a>QShader::<span class="name">~QShader</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QShader -->
<!-- $$$availableShaders[overload1]$$$availableShaders -->
<h3 class="fn" id="availableShaders"><a name="availableShaders"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderkey.html">QShaderKey</a></span>&gt; QShader::<span class="name">availableShaders</span>() const</h3>
<p>Returns the list of available shader versions</p>
<!-- @@@availableShaders -->
<!-- $$$description[overload1]$$$description -->
<h3 class="fn" id="description"><a name="description"></a><span class="type">int</span> QShader::<span class="name">description</span>() const</h3>
<p>Returns the reflection metadata for the shader.</p>
<p><b>See also </b><a href="qshader.html#setDescription">setDescription</a>().</p>
<!-- @@@description -->
<!-- $$$fromSerialized[overload1]$$$fromSerializedconstQByteArray& -->
<h3 class="fn" id="fromSerialized"><a name="fromSerialized"></a><code>[static] </code><span class="type"><a href="qshader.html#QShader">QShader</a></span> QShader::<span class="name">fromSerialized</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Creates a new <a href="qshader.html">QShader</a> instance from the given <i>data</i>.</p>
<p><b>See also </b><a href="qshader.html#serialized">serialized</a>().</p>
<!-- @@@fromSerialized -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid"><a name="isValid"></a><span class="type">bool</span> QShader::<span class="name">isValid</span>() const</h3>
<p>Returns true if the <a href="qshader.html">QShader</a> contains at least one shader version.</p>
<!-- @@@isValid -->
<!-- $$$removeShader[overload1]$$$removeShaderconstQShaderKey& -->
<h3 class="fn" id="removeShader"><a name="removeShader"></a><span class="type">void</span> QShader::<span class="name">removeShader</span>(const <span class="type"><a href="qshaderkey.html">QShaderKey</a></span> &amp;<i>key</i>)</h3>
<p>Removes the source or binary shader code for a given <i>key</i>. Does nothing when not found.</p>
<!-- @@@removeShader -->
<!-- $$$serialized[overload1]$$$serialized -->
<h3 class="fn" id="serialized"><a name="serialized"></a><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QShader::<span class="name">serialized</span>() const</h3>
<p>Returns a serialized binary version of all the data held by the <a href="qshader.html">QShader</a>, suitable for writing to files or other I/O devices.</p>
<p><b>See also </b><a href="qshader.html#fromSerialized">fromSerialized</a>().</p>
<!-- @@@serialized -->
<!-- $$$setDescription[overload1]$$$setDescriptionconstint& -->
<h3 class="fn" id="setDescription"><a name="setDescription"></a><span class="type">void</span> QShader::<span class="name">setDescription</span>(const <span class="type">int</span> &amp;<i>desc</i>)</h3>
<p><b>See also </b><a href="qshader.html#description">description</a>().</p>
<!-- @@@setDescription -->
<!-- $$$setShader[overload1]$$$setShaderconstQShaderKey&constQShaderCode& -->
<h3 class="fn" id="setShader"><a name="setShader"></a><span class="type">void</span> QShader::<span class="name">setShader</span>(const <span class="type"><a href="qshaderkey.html">QShaderKey</a></span> &amp;<i>key</i>, const <span class="type"><a href="qshadercode.html">QShaderCode</a></span> &amp;<i>shader</i>)</h3>
<p>Stores the source or binary <i>shader</i> code for a given shader version specified by <i>key</i>.</p>
<p><b>See also </b><a href="qshader.html#shader">shader</a>().</p>
<!-- @@@setShader -->
<!-- $$$setStage[overload1]$$$setStageQShader::Stage -->
<h3 class="fn" id="setStage"><a name="setStage"></a><span class="type">void</span> QShader::<span class="name">setStage</span>(<span class="type"><a href="qshader.html#Stage-enum">QShader::Stage</a></span> <i>stage</i>)</h3>
<p>Sets the pipeline <i>stage</i>.</p>
<p><b>See also </b><a href="qshader.html#stage">stage</a>().</p>
<!-- @@@setStage -->
<!-- $$$shader[overload1]$$$shaderconstQShaderKey& -->
<h3 class="fn" id="shader"><a name="shader"></a><span class="type"><a href="qshadercode.html">QShaderCode</a></span> QShader::<span class="name">shader</span>(const <span class="type"><a href="qshaderkey.html">QShaderKey</a></span> &amp;<i>key</i>) const</h3>
<p>Returns the source or binary code for a given shader version specified by <i>key</i>.</p>
<p><b>See also </b><a href="qshader.html#setShader">setShader</a>().</p>
<!-- @@@shader -->
<!-- $$$stage[overload1]$$$stage -->
<h3 class="fn" id="stage"><a name="stage"></a><span class="type"><a href="qshader.html#Stage-enum">QShader::Stage</a></span> QShader::<span class="name">stage</span>() const</h3>
<p>Returns the pipeline stage the shader is meant for.</p>
<p><b>See also </b><a href="qshader.html#setStage">setStage</a>().</p>
<!-- @@@stage -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash[overload1]$$$qHashconstQShader&uint -->
<h3 class="fn" id="qHash"><a name="qHash"></a><span class="type"><a href="../qtcore/qtglobal.html#uint-typedef">uint</a></span> <span class="name">qHash</span>(const <span class="type"><a href="qshader.html#QShader">QShader</a></span> &amp;<i>s</i>, <span class="type"><a href="../qtcore/qtglobal.html#uint-typedef">uint</a></span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for <i>s</i>, using <i>seed</i> to seed the calculation.</p>
<!-- @@@qHash -->
<!-- $$$operator!=[overload1]$$$operator!=constQShader&constQShader& -->
<h3 class="fn" id="operator-not-eq"><a name="operator-not-eq"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="qshader.html#QShader">QShader</a></span> &amp;<i>lhs</i>, const <span class="type"><a href="qshader.html#QShader">QShader</a></span> &amp;<i>rhs</i>)</h3>
<p>Returns <code>false</code> if the values in the two <a href="qshader.html">QShader</a> objects <i>a</i> and <i>b</i> are equal; otherwise returns <code>true</code>.</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQShader&constQShader& -->
<h3 class="fn" id="operator-eq-eq"><a name="operator-eq-eq"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="qshader.html#QShader">QShader</a></span> &amp;<i>lhs</i>, const <span class="type"><a href="qshader.html#QShader">QShader</a></span> &amp;<i>rhs</i>)</h3>
<p>Returns <code>true</code> if the two <a href="qshader.html">QShader</a> objects <i>a</i> and <i>b</i> are equal, meaning they are for the same stage with matching sets of shader source or binary code.</p>
<!-- @@@operator== -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
