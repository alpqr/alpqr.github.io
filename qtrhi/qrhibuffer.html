<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qrhi.cpp -->
  <title>QRhiBuffer Class | RHI 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td >Qt 5.12</td><td ><a href="qtrhi-index.html">RHI</a></td><td ><a href="qtrhi-module.html">C++ Classes</a></td><td >QRhiBuffer</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.12.0 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#protected-variables">Protected Variables</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QRhiBuffer Class</h1>
<!-- $$$QRhiBuffer-brief -->
<p>Vertex, index, or uniform (constant) buffer resource. <a href="#details">More...</a></p>
<!-- @@@QRhiBuffer -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QRhiBuffer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += rhi</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qrhiresource.html">QRhiResource</a></td></tr></table></div><ul>
<li><a href="qrhibuffer-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#Type-enum">Type</a></b> { Immutable, Static, Dynamic }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#UsageFlag-enum">UsageFlag</a></b> { VertexBuffer, IndexBuffer, UniformBuffer }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#UsageFlag-enum">UsageFlags</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#build">build</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#setSize">setSize</a></b>(int <i>sz</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#setType">setType</a></b>(QRhiBuffer::Type <i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#setUsage">setUsage</a></b>(QRhiBuffer::UsageFlags <i>u</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiBuffer::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#type">type</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiBuffer::UsageFlags </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#usage">usage</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">6 public functions inherited from <a href="qrhiresource.html#public-functions">QRhiResource</a></li>
</ul>
<a name="protected-variables"></a>
<h2 id="protected-variables">Protected Variables</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#m_reserved-var">m_reserved</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#m_size-var">m_size</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiBuffer::Type </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#m_type-var">m_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRhiBuffer::UsageFlags </td><td class="memItemRight bottomAlign"><b><a href="qrhibuffer.html#m_usage-var">m_usage</a></b></td></tr>
</table></div>
<ul>
<li class="fn">5 protected variables inherited from <a href="qrhiresource.html#protected-variables">QRhiResource</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 protected function inherited from <a href="qrhiresource.html#protected-functions">QRhiResource</a></li>
</ul>
<a name="details"></a>
<!-- $$$QRhiBuffer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Vertex, index, or uniform (constant) buffer resource.</p>
</div>
<!-- @@@QRhiBuffer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Type$$$Immutable$$$Static$$$Dynamic -->
<h3 class="fn" id="Type-enum"><a name="Type-enum"></a>enum QRhiBuffer::<span class="name">Type</span></h3>
<p>Specifies storage type of buffer resource.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QRhiBuffer::Immutable</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">Indicates that the data is not expected to change ever after the initial upload. Under the hood such buffer resources are typically placed in device local (GPU) memory (on systems where applicable). Uploading new data is possible, but may be expensive. The upload typically happens by copying to a separate, host visible staging buffer from which a GPU buffer-to-buffer copy is issued into the actual GPU-only buffer.</td></tr>
<tr><td class="topAlign"><code>QRhiBuffer::Static</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">Indicates that the data is expected to change only infrequently. Typically placed in device local (GPU) memory, where applicable. On backends where host visible staging buffers are used for uploading, the staging buffers are kept around for this type, unlike with Immutable, so subsequent uploads do not suffer in performance. Frequent updates, especially updates in consecutive frames, should be avoided.</td></tr>
<tr><td class="topAlign"><code>QRhiBuffer::Dynamic</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">Indicates that the data is expected to change frequently. Not recommended for large buffers. Typically backed by host visible memory in 2 copies in order to allow for changing without stalling the graphics pipeline. The double buffering is managed transparently to the applications and is not exposed in the API here in any form. This is the recommended, and, with some backends, the only possible, type for buffers with <a href="qrhibuffer.html#UsageFlag-enum">UniformBuffer</a> usage.</td></tr>
</table></div>
<!-- @@@Type -->
<!-- $$$UsageFlag$$$VertexBuffer$$$IndexBuffer$$$UniformBuffer -->
<h3 class="flags" id="UsageFlag-enum"><a name="UsageFlag-enum"></a>enum QRhiBuffer::<span class="name">UsageFlag</span><br/>flags QRhiBuffer::<span class="name">UsageFlags</span></h3>
<p>Flag values to specify how the buffer is going to be used.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QRhiBuffer::VertexBuffer</code></td><td class="topAlign tblval"><code>1 &lt;&lt; 0</code></td><td class="topAlign">Vertex buffer</td></tr>
<tr><td class="topAlign"><code>QRhiBuffer::IndexBuffer</code></td><td class="topAlign tblval"><code>1 &lt;&lt; 1</code></td><td class="topAlign">Index buffer</td></tr>
<tr><td class="topAlign"><code>QRhiBuffer::UniformBuffer</code></td><td class="topAlign tblval"><code>1 &lt;&lt; 2</code></td><td class="topAlign">Uniform (constant) buffer</td></tr>
</table></div>
<p>The UsageFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;UsageFlag&gt;. It stores an OR combination of UsageFlag values.</p>
<!-- @@@UsageFlag -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$build[overload1]$$$build -->
<h3 class="fn" id="build"><a name="build"></a><code>[pure virtual] </code><span class="type">bool</span> QRhiBuffer::<span class="name">build</span>()</h3>
<p>Creates the corresponding native graphics resources. If there are already resources present due to an earlier build() with no corresponding <a href="qrhiresource.html#release">release</a>(), then <a href="qrhiresource.html#release">release</a>() is called implicitly first.</p>
<p>Returns <code>true</code> when successful, <code>false</code> when a graphics operation failed. Regardless of the return value, calling <a href="qrhiresource.html#release">release</a>() is always safe.</p>
<!-- @@@build -->
<!-- $$$setSize[overload1]$$$setSizeint -->
<h3 class="fn" id="setSize"><a name="setSize"></a><span class="type">void</span> QRhiBuffer::<span class="name">setSize</span>(<span class="type">int</span> <i>sz</i>)</h3>
<p>Sets the size of the buffer in bytes. The size is normally specified in <a href="qrhi.html#newBuffer">QRhi::newBuffer</a>() so this function is only used when the size has to be changed. As with other setters, the size only takes effect when calling <a href="qrhibuffer.html#build">build</a>(), and for already built buffers this involves releasing the previous native resource and creating new ones under the hood.</p>
<p>Backends may choose to allocate buffers bigger than <i>sz</i> in order to fulfill alignment requirements. This is hidden from the applications and <a href="qrhibuffer.html#size">size</a>() will always report the size requested in <i>sz</i>.</p>
<p><b>See also </b><a href="qrhibuffer.html#size">size</a>().</p>
<!-- @@@setSize -->
<!-- $$$setType[overload1]$$$setTypeQRhiBuffer::Type -->
<h3 class="fn" id="setType"><a name="setType"></a><span class="type">void</span> QRhiBuffer::<span class="name">setType</span>(<span class="type"><a href="qrhibuffer.html#Type-enum">QRhiBuffer::Type</a></span> <i>t</i>)</h3>
<p><b>See also </b><a href="qrhibuffer.html#type">type</a>().</p>
<!-- @@@setType -->
<!-- $$$setUsage[overload1]$$$setUsageQRhiBuffer::UsageFlags -->
<h3 class="fn" id="setUsage"><a name="setUsage"></a><span class="type">void</span> QRhiBuffer::<span class="name">setUsage</span>(<span class="type"><a href="qrhibuffer.html#UsageFlag-enum">QRhiBuffer::UsageFlags</a></span> <i>u</i>)</h3>
<p><b>See also </b><a href="qrhibuffer.html#usage">usage</a>().</p>
<!-- @@@setUsage -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><span class="type">int</span> QRhiBuffer::<span class="name">size</span>() const</h3>
<p><b>See also </b><a href="qrhibuffer.html#setSize">setSize</a>().</p>
<!-- @@@size -->
<!-- $$$type[overload1]$$$type -->
<h3 class="fn" id="type"><a name="type"></a><span class="type"><a href="qrhibuffer.html#Type-enum">QRhiBuffer::Type</a></span> QRhiBuffer::<span class="name">type</span>() const</h3>
<p><b>See also </b><a href="qrhibuffer.html#setType">setType</a>().</p>
<!-- @@@type -->
<!-- $$$usage[overload1]$$$usage -->
<h3 class="fn" id="usage"><a name="usage"></a><span class="type"><a href="qrhibuffer.html#UsageFlag-enum">QRhiBuffer::UsageFlags</a></span> QRhiBuffer::<span class="name">usage</span>() const</h3>
<p><b>See also </b><a href="qrhibuffer.html#setUsage">setUsage</a>().</p>
<!-- @@@usage -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
</div>
<div class="macros">
<h2>Macro Documentation</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
