<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qshaderdescription.cpp -->
  <title>QShaderDescription Class | RHI 5.12</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td >Qt 5.12</td><td ><a href="qtrhi-index.html">RHI</a></td><td ><a href="qtrhi-module.html">C++ Classes</a></td><td >QShaderDescription</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.12.0 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#example">Example</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QShaderDescription Class</h1>
<!-- $$$QShaderDescription-brief -->
<p>Describes the interface of a shader. <a href="#details">More...</a></p>
<!-- @@@QShaderDescription -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QShaderDescription&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += rhi</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  Qt 5.14</td></tr></table></div><ul>
<li><a href="qshaderdescription-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription-blockvariable.html">BlockVariable</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription-inoutvariable.html">InOutVariable</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription-pushconstantblock.html">PushConstantBlock</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription-storageblock.html">StorageBlock</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription-uniformblock.html">UniformBlock</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#ImageFlag-enum">ImageFlag</a></b> { ReadOnlyImage, WriteOnlyImage }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#ImageFlag-enum">ImageFlags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#ImageFormat-enum">ImageFormat</a></b> { ImageFormatUnknown, ImageFormatRgba32f, ImageFormatRgba16f, ImageFormatR32f, ..., ImageFormatR8ui }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#VariableType-enum">VariableType</a></b> { Unknown, Float, Vec2, Vec3, ..., Struct }</td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#QShaderDescription">QShaderDescription</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#dtor.QShaderDescription">~QShaderDescription</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderDescription::InOutVariable&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#combinedImageSamplers">combinedImageSamplers</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderDescription::InOutVariable&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#inputVariables">inputVariables</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#isValid">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderDescription::InOutVariable&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#outputVariables">outputVariables</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderDescription::PushConstantBlock&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#pushConstantBlocks">pushConstantBlocks</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderDescription::StorageBlock&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#storageBlocks">storageBlocks</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderDescription::InOutVariable&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#storageImages">storageImages</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#toBinaryJson">toBinaryJson</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#toJson">toJson</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QShaderDescription::UniformBlock&gt; </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#uniformBlocks">uniformBlocks</a></b>() const</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QShaderDescription </td><td class="memItemRight bottomAlign"><b><a href="qshaderdescription.html#fromBinaryJson">fromBinaryJson</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QShaderDescription-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Describes the interface of a shader.</p>
<p>A shader typically has a set of inputs and outputs. A vertex shader for example has a number of input variables and may use one or more uniform buffers to access data (e.g&#x2e; a modelview matrix) provided by the application. The shader for the fragment stage receives data from the vertex stage (in a simple setup) and may also rely on data from uniform buffers, images, and samplers.</p>
<p>When it comes to vertex inputs and the layout of the uniform buffers (what are the names of the members? what is there size, offset, and so on), applications and frameworks may need to discover this dynamically at run time. This is typical when the shader is not built-in but provided by an external entity, like the user.</p>
<p>Modern and lean graphics APIs may no longer provide a way to query shader reflection information at run time. Therefore, such data is now automatically generated by QShaderBaker and is provided as a <a href="qshaderdescription.html">QShaderDescription</a> object for each and every QShader.</p>
<a name="example"></a>
<h4 >Example</h4>
<p>Take the following vertex shader:</p>
<pre class="cpp plain">

  #version 440

  layout(location = 0) in vec4 position;
  layout(location = 1) in vec3 color;
  layout(location = 0) out vec3 v_color;

  layout(std140, binding = 0) uniform buf {
      mat4 mvp;
      float opacity;
  } ubuf;

  out gl_PerVertex { vec4 gl_Position; };

  void main()
  {
      v_color = color;
      gl_Position = ubuf.mvp * position;
  }

</pre>
<p>This shader has two inputs: <code>position</code> at location 0 with a type of <code>vec4</code>, and <code>color</code> at location 1 with a type of <code>vec3</code>. It has one output: <code>v_color</code>, although this is typically not interesting for applications. What is more important, there is a uniform block at binding 0 with a size of 68 bytes and two members, a 4x4 matrix named <code>mvp</code> at offset 0, and a float <code>opacity</code> at offset 64.</p>
<p>All this is described by a <a href="qshaderdescription.html">QShaderDescription</a> object. <a href="qshaderdescription.html">QShaderDescription</a> can also be serialized to JSON and binary JSON, and can be deserialized from binary JSON. In practice this is rarely needed since QShader takes care of the associated <a href="qshaderdescription.html">QShaderDescription</a> automatically, but if the <a href="qshaderdescription.html">QShaderDescription</a> of the above shader would be written out as JSON, it would look like the following:</p>
<pre class="cpp plain">

  {
      &quot;inputs&quot;: [
          {
              &quot;location&quot;: 1,
              &quot;name&quot;: &quot;color&quot;,
              &quot;type&quot;: &quot;vec3&quot;
          },
          {
              &quot;location&quot;: 0,
              &quot;name&quot;: &quot;position&quot;,
              &quot;type&quot;: &quot;vec4&quot;
          }
      ],
      &quot;outputs&quot;: [
          {
              &quot;location&quot;: 0,
              &quot;name&quot;: &quot;v_color&quot;,
              &quot;type&quot;: &quot;vec3&quot;
          }
      ],
      &quot;uniformBlocks&quot;: [
          {
              &quot;binding&quot;: 0,
              &quot;blockName&quot;: &quot;buf&quot;,
              &quot;members&quot;: [
                  {
                      &quot;matrixStride&quot;: 16,
                      &quot;name&quot;: &quot;mvp&quot;,
                      &quot;offset&quot;: 0,
                      &quot;size&quot;: 64,
                      &quot;type&quot;: &quot;mat4&quot;
                  },
                  {
                      &quot;name&quot;: &quot;opacity&quot;,
                      &quot;offset&quot;: 64,
                      &quot;size&quot;: 4,
                      &quot;type&quot;: &quot;float&quot;
                  }
              ],
              &quot;set&quot;: 0,
              &quot;size&quot;: 68,
              &quot;structName&quot;: &quot;ubuf&quot;
          }
      ]
  }

</pre>
<p>The C++ API allows accessing a data structure like the above. For simplicity the inner structs only contain public data members, also considering that their layout is unlikely to change in the future.</p>
</div>
<p><b>See also </b>QShaderBaker and QShader.</p>
<!-- @@@QShaderDescription -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ImageFlag$$$ReadOnlyImage$$$WriteOnlyImage -->
<h3 class="flags" id="ImageFlag-enum"><a name="ImageFlag-enum"></a>enum QShaderDescription::<span class="name">ImageFlag</span><br/>flags QShaderDescription::<span class="name">ImageFlags</span></h3>
<p>The ImageFlags type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;ImageFlag&gt;. It stores an OR combination of ImageFlag values.</p>
<!-- @@@ImageFlag -->
<!-- $$$ImageFormat$$$ImageFormatUnknown$$$ImageFormatRgba32f$$$ImageFormatRgba16f$$$ImageFormatR32f$$$ImageFormatRgba8$$$ImageFormatRgba8Snorm$$$ImageFormatRg32f$$$ImageFormatRg16f$$$ImageFormatR11fG11fB10f$$$ImageFormatR16f$$$ImageFormatRgba16$$$ImageFormatRgb10A2$$$ImageFormatRg16$$$ImageFormatRg8$$$ImageFormatR16$$$ImageFormatR8$$$ImageFormatRgba16Snorm$$$ImageFormatRg16Snorm$$$ImageFormatRg8Snorm$$$ImageFormatR16Snorm$$$ImageFormatR8Snorm$$$ImageFormatRgba32i$$$ImageFormatRgba16i$$$ImageFormatRgba8i$$$ImageFormatR32i$$$ImageFormatRg32i$$$ImageFormatRg16i$$$ImageFormatRg8i$$$ImageFormatR16i$$$ImageFormatR8i$$$ImageFormatRgba32ui$$$ImageFormatRgba16ui$$$ImageFormatRgba8ui$$$ImageFormatR32ui$$$ImageFormatRgb10a2ui$$$ImageFormatRg32ui$$$ImageFormatRg16ui$$$ImageFormatRg8ui$$$ImageFormatR16ui$$$ImageFormatR8ui -->
<h3 class="fn" id="ImageFormat-enum"><a name="ImageFormat-enum"></a>enum QShaderDescription::<span class="name">ImageFormat</span></h3>
<!-- @@@ImageFormat -->
<!-- $$$VariableType$$$Unknown$$$Float$$$Vec2$$$Vec3$$$Vec4$$$Mat2$$$Mat2x3$$$Mat2x4$$$Mat3$$$Mat3x2$$$Mat3x4$$$Mat4$$$Mat4x2$$$Mat4x3$$$Int$$$Int2$$$Int3$$$Int4$$$Uint$$$Uint2$$$Uint3$$$Uint4$$$Bool$$$Bool2$$$Bool3$$$Bool4$$$Double$$$Double2$$$Double3$$$Double4$$$DMat2$$$DMat2x3$$$DMat2x4$$$DMat3$$$DMat3x2$$$DMat3x4$$$DMat4$$$DMat4x2$$$DMat4x3$$$Sampler1D$$$Sampler2D$$$Sampler2DMS$$$Sampler3D$$$SamplerCube$$$Sampler1DArray$$$Sampler2DArray$$$Sampler2DMSArray$$$Sampler3DArray$$$SamplerCubeArray$$$SamplerRect$$$SamplerBuffer$$$Image1D$$$Image2D$$$Image2DMS$$$Image3D$$$ImageCube$$$Image1DArray$$$Image2DArray$$$Image2DMSArray$$$Image3DArray$$$ImageCubeArray$$$ImageRect$$$ImageBuffer$$$Struct -->
<h3 class="fn" id="VariableType-enum"><a name="VariableType-enum"></a>enum QShaderDescription::<span class="name">VariableType</span></h3>
<p>Represents the type of a variable or block member.</p>
<div class="table"><table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td class="topAlign"><code>QShaderDescription::Unknown</code></td><td class="topAlign tblval"><code>0</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Float</code></td><td class="topAlign tblval"><code>1</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Vec2</code></td><td class="topAlign tblval"><code>2</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Vec3</code></td><td class="topAlign tblval"><code>3</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Vec4</code></td><td class="topAlign tblval"><code>4</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat2</code></td><td class="topAlign tblval"><code>5</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat2x3</code></td><td class="topAlign tblval"><code>6</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat2x4</code></td><td class="topAlign tblval"><code>7</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat3</code></td><td class="topAlign tblval"><code>8</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat3x2</code></td><td class="topAlign tblval"><code>9</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat3x4</code></td><td class="topAlign tblval"><code>10</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat4</code></td><td class="topAlign tblval"><code>11</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat4x2</code></td><td class="topAlign tblval"><code>12</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Mat4x3</code></td><td class="topAlign tblval"><code>13</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Int</code></td><td class="topAlign tblval"><code>14</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Int2</code></td><td class="topAlign tblval"><code>15</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Int3</code></td><td class="topAlign tblval"><code>16</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Int4</code></td><td class="topAlign tblval"><code>17</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Uint</code></td><td class="topAlign tblval"><code>18</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Uint2</code></td><td class="topAlign tblval"><code>19</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Uint3</code></td><td class="topAlign tblval"><code>20</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Uint4</code></td><td class="topAlign tblval"><code>21</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Bool</code></td><td class="topAlign tblval"><code>22</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Bool2</code></td><td class="topAlign tblval"><code>23</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Bool3</code></td><td class="topAlign tblval"><code>24</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Bool4</code></td><td class="topAlign tblval"><code>25</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Double</code></td><td class="topAlign tblval"><code>26</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Double2</code></td><td class="topAlign tblval"><code>27</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Double3</code></td><td class="topAlign tblval"><code>28</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Double4</code></td><td class="topAlign tblval"><code>29</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat2</code></td><td class="topAlign tblval"><code>30</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat2x3</code></td><td class="topAlign tblval"><code>31</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat2x4</code></td><td class="topAlign tblval"><code>32</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat3</code></td><td class="topAlign tblval"><code>33</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat3x2</code></td><td class="topAlign tblval"><code>34</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat3x4</code></td><td class="topAlign tblval"><code>35</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat4</code></td><td class="topAlign tblval"><code>36</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat4x2</code></td><td class="topAlign tblval"><code>37</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::DMat4x3</code></td><td class="topAlign tblval"><code>38</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler1D</code></td><td class="topAlign tblval"><code>39</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler2D</code></td><td class="topAlign tblval"><code>40</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler2DMS</code></td><td class="topAlign tblval"><code>41</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler3D</code></td><td class="topAlign tblval"><code>42</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::SamplerCube</code></td><td class="topAlign tblval"><code>43</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler1DArray</code></td><td class="topAlign tblval"><code>44</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler2DArray</code></td><td class="topAlign tblval"><code>45</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler2DMSArray</code></td><td class="topAlign tblval"><code>46</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Sampler3DArray</code></td><td class="topAlign tblval"><code>47</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::SamplerCubeArray</code></td><td class="topAlign tblval"><code>48</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::SamplerRect</code></td><td class="topAlign tblval"><code>49</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::SamplerBuffer</code></td><td class="topAlign tblval"><code>50</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image1D</code></td><td class="topAlign tblval"><code>51</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image2D</code></td><td class="topAlign tblval"><code>52</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image2DMS</code></td><td class="topAlign tblval"><code>53</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image3D</code></td><td class="topAlign tblval"><code>54</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::ImageCube</code></td><td class="topAlign tblval"><code>55</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image1DArray</code></td><td class="topAlign tblval"><code>56</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image2DArray</code></td><td class="topAlign tblval"><code>57</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image2DMSArray</code></td><td class="topAlign tblval"><code>58</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Image3DArray</code></td><td class="topAlign tblval"><code>59</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::ImageCubeArray</code></td><td class="topAlign tblval"><code>60</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::ImageRect</code></td><td class="topAlign tblval"><code>61</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::ImageBuffer</code></td><td class="topAlign tblval"><code>62</code></td></tr>
<tr><td class="topAlign"><code>QShaderDescription::Struct</code></td><td class="topAlign tblval"><code>63</code></td></tr>
</table></div>
<!-- @@@VariableType -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QShaderDescription[overload1]$$$QShaderDescription -->
<h3 class="fn" id="QShaderDescription"><a name="QShaderDescription"></a>QShaderDescription::<span class="name">QShaderDescription</span>()</h3>
<p>Constructs a new, empty <a href="qshaderdescription.html">QShaderDescription</a>.</p>
<p><b>Note: </b>Being empty implies that <a href="qshaderdescription.html#isValid">isValid</a>() returns <code>false</code> for the newly constructed instance.</p><!-- @@@QShaderDescription -->
<!-- $$$~QShaderDescription[overload1]$$$~QShaderDescription -->
<h3 class="fn" id="dtor.QShaderDescription"><a name="dtor.QShaderDescription"></a>QShaderDescription::<span class="name">~QShaderDescription</span>()</h3>
<p>Destructor.</p>
<!-- @@@~QShaderDescription -->
<!-- $$$combinedImageSamplers[overload1]$$$combinedImageSamplers -->
<h3 class="fn" id="combinedImageSamplers"><a name="combinedImageSamplers"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderdescription-inoutvariable.html">QShaderDescription::InOutVariable</a></span>&gt; QShaderDescription::<span class="name">combinedImageSamplers</span>() const</h3>
<p>Returns the list of combined image samplers</p>
<p>With GLSL/Vulkan shaders as source a <code>layout(binding = 1) uniform sampler2D tex;</code> uniform generates the following: (shown as textual JSON here)</p>
<pre class="cpp plain">

  &quot;combinedImageSamplers&quot;: [
       {
           &quot;binding&quot;: 1,
           &quot;name&quot;: &quot;tex&quot;,
           &quot;set&quot;: 0,
           &quot;type&quot;: &quot;sampler2D&quot;
       }
   ]

</pre>
<p>This does not mean that other language versions of the shader must also use a combined image sampler, especially considering that the concept may not exist everywhere. For instance, a HLSL version will likely just use a Texture2D and SamplerState object with registers t1 and s1, respectively.</p>
<!-- @@@combinedImageSamplers -->
<!-- $$$fromBinaryJson[overload1]$$$fromBinaryJsonconstQByteArray& -->
<h3 class="fn" id="fromBinaryJson"><a name="fromBinaryJson"></a><code>[static] </code><span class="type"><a href="qshaderdescription.html#QShaderDescription">QShaderDescription</a></span> QShaderDescription::<span class="name">fromBinaryJson</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Deserializes the given binary JSON <i>data</i> and returns a new <a href="qshaderdescription.html">QShaderDescription</a>.</p>
<!-- @@@fromBinaryJson -->
<!-- $$$inputVariables[overload1]$$$inputVariables -->
<h3 class="fn" id="inputVariables"><a name="inputVariables"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderdescription-inoutvariable.html">QShaderDescription::InOutVariable</a></span>&gt; QShaderDescription::<span class="name">inputVariables</span>() const</h3>
<p>Returns the list of input variables. This includes vertex inputs (sometimes called attributes) for the vertex stage, and inputs for other stages (sometimes called varyings).</p>
<!-- @@@inputVariables -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid"><a name="isValid"></a><span class="type">bool</span> QShaderDescription::<span class="name">isValid</span>() const</h3>
<p>Returns true if the <a href="qshaderdescription.html">QShaderDescription</a> contains at least one entry in one of the variable and block lists.</p>
<!-- @@@isValid -->
<!-- $$$outputVariables[overload1]$$$outputVariables -->
<h3 class="fn" id="outputVariables"><a name="outputVariables"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderdescription-inoutvariable.html">QShaderDescription::InOutVariable</a></span>&gt; QShaderDescription::<span class="name">outputVariables</span>() const</h3>
<p>Returns the list of output variables.</p>
<!-- @@@outputVariables -->
<!-- $$$pushConstantBlocks[overload1]$$$pushConstantBlocks -->
<h3 class="fn" id="pushConstantBlocks"><a name="pushConstantBlocks"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderdescription-pushconstantblock.html">QShaderDescription::PushConstantBlock</a></span>&gt; QShaderDescription::<span class="name">pushConstantBlocks</span>() const</h3>
<p>Returns the list of push constant blocks.</p>
<p><b>Note: </b>Avoid relying on push constant blocks for shaders that are to be used in combination with the Qt Rendering Hardware Interface since that currently has no support for them.</p><!-- @@@pushConstantBlocks -->
<!-- $$$storageBlocks[overload1]$$$storageBlocks -->
<h3 class="fn" id="storageBlocks"><a name="storageBlocks"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderdescription-storageblock.html">QShaderDescription::StorageBlock</a></span>&gt; QShaderDescription::<span class="name">storageBlocks</span>() const</h3>
<p>Returns the list of shader storage blocks.</p>
<p>For example, with GLSL/Vulkan shaders as source, the declaration</p>
<pre class="cpp plain">

  struct Stuff {
      vec2 a;
      vec2 b;
  };
  layout(std140, binding = 0) buffer StuffSsbo {
      vec4 whatever;
      Stuff stuff[];
  } buf;

</pre>
<p>generates the following: (shown as textual JSON here)</p>
<pre class="cpp plain">

  &quot;storageBlocks&quot;: [ {
      &quot;binding&quot;: 0,
      &quot;blockName&quot;: &quot;StuffSsbo&quot;,
      &quot;instanceName&quot;: &quot;buf&quot;,
      &quot;knownSize&quot;: 16,
      &quot;members&quot;: [
          {
              &quot;name&quot;: &quot;whatever&quot;,
              &quot;offset&quot;: 0,
              &quot;size&quot;: 16,
              &quot;type&quot;: &quot;vec4&quot;
          },
          {
              &quot;arrayDims&quot;: [
                  0
              ],
              &quot;name&quot;: &quot;stuff&quot;,
              &quot;offset&quot;: 16,
              &quot;size&quot;: 0,
              &quot;structMembers&quot;: [
                  {
                      &quot;name&quot;: &quot;a&quot;,
                      &quot;offset&quot;: 0,
                      &quot;size&quot;: 8,
                      &quot;type&quot;: &quot;vec2&quot;
                  },
                  {
                      &quot;name&quot;: &quot;b&quot;,
                      &quot;offset&quot;: 8,
                      &quot;size&quot;: 8,
                      &quot;type&quot;: &quot;vec2&quot;
                  }
              ],
              &quot;type&quot;: &quot;struct&quot;
          }
      ],
      &quot;set&quot;: 0
  } ]

</pre>
<p><b>Note: </b>The size of the last member in the storage block is undefined. This shows up as <code>size</code> 0 and an array dimension of <code>[0]</code>. The storage block's <code>knownSize</code> excludes the size of the last member since that will only be known at run time.</p><p><b>Note: </b>SSBOs are not available with some graphics APIs, such as, OpenGL 2.x or OpenGL ES older than 3.1&#x2e;</p><!-- @@@storageBlocks -->
<!-- $$$storageImages[overload1]$$$storageImages -->
<h3 class="fn" id="storageImages"><a name="storageImages"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderdescription-inoutvariable.html">QShaderDescription::InOutVariable</a></span>&gt; QShaderDescription::<span class="name">storageImages</span>() const</h3>
<p>Returns the list of image variables.</p>
<p>These will likely occur in compute shaders. For example, <code>layout (binding = 0, rgba8) uniform readonly image2D inputImage;</code> generates the following: (shown as textual JSON here)</p>
<pre class="cpp plain">

  &quot;storageImages&quot;: [
       {
           &quot;binding&quot;: 0,
           &quot;imageFormat&quot;: &quot;rgba8&quot;,
           &quot;name&quot;: &quot;inputImage&quot;,
           &quot;set&quot;: 0,
           &quot;type&quot;: &quot;image2D&quot;
       }
   ]

</pre>
<p><b>Note: </b>Separate image objects are not compatible with some graphics APIs, such as, OpenGL 2.x or OpenGL ES older than 3.1&#x2e;</p><!-- @@@storageImages -->
<!-- $$$toBinaryJson[overload1]$$$toBinaryJson -->
<h3 class="fn" id="toBinaryJson"><a name="toBinaryJson"></a><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QShaderDescription::<span class="name">toBinaryJson</span>() const</h3>
<p>Returns a serialized binary version of the data.</p>
<p><b>See also </b><a href="qshaderdescription.html#toJson">toJson</a>().</p>
<!-- @@@toBinaryJson -->
<!-- $$$toJson[overload1]$$$toJson -->
<h3 class="fn" id="toJson"><a name="toJson"></a><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QShaderDescription::<span class="name">toJson</span>() const</h3>
<p>Returns a serialized JSON text version of the data.</p>
<p><b>Note: </b>There is no deserialization method provided for JSON text.</p><p><b>See also </b><a href="qshaderdescription.html#toBinaryJson">toBinaryJson</a>().</p>
<!-- @@@toJson -->
<!-- $$$uniformBlocks[overload1]$$$uniformBlocks -->
<h3 class="fn" id="uniformBlocks"><a name="uniformBlocks"></a><span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type"><a href="qshaderdescription-uniformblock.html">QShaderDescription::UniformBlock</a></span>&gt; QShaderDescription::<span class="name">uniformBlocks</span>() const</h3>
<p>Returns the list of uniform blocks.</p>
<!-- @@@uniformBlocks -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
</div>
<div class="macros">
<h2>Macro Documentation</h2>
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
